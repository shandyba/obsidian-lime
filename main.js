/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidunlimePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  hideUnlinkedMentions: false,
  hideUnlinkedMentionsOutgoing: false,
  verboseLogging: false
};
var ObsidunlimePlugin = class extends import_obsidian.Plugin {
  log(...args) {
    if (this.settings.verboseLogging) {
      console.log("[Obsidunlime]", ...args);
    }
  }
  async onload() {
    await this.loadSettings();
    console.log("Loading Obsidunlime plugin");
    this.addSettingTab(new ObsidunlimeSettingTab(this.app, this));
    this.styleEl = document.createElement("style");
    document.head.appendChild(this.styleEl);
    this.updateUnlinkedMentionsVisibility();
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateUnlinkedMentionsVisibility();
      })
    );
    let debounceTimer;
    this.observer = new MutationObserver((mutations) => {
      const relevantMutation = mutations.some((mutation) => {
        const target = mutation.target;
        return target.closest('.workspace-leaf-content[data-type="backlink"]') || target.closest('.workspace-leaf-content[data-type="outgoing-link"]') || mutation.addedNodes.length > 0;
      });
      if (relevantMutation && (this.settings.hideUnlinkedMentions || this.settings.hideUnlinkedMentionsOutgoing)) {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
          const panelTypes = [];
          if (this.settings.hideUnlinkedMentions) {
            panelTypes.push("backlink");
          }
          if (this.settings.hideUnlinkedMentionsOutgoing) {
            panelTypes.push("outgoing-link");
          }
          this.hideUnlinkedMentionsByText(panelTypes);
        }, 100);
      }
    });
    this.app.workspace.onLayoutReady(() => {
      const workspaceEl = document.querySelector(".workspace");
      if (workspaceEl) {
        this.observer.observe(workspaceEl, {
          childList: true,
          subtree: true,
          attributes: true,
          attributeFilter: ["class", "style"]
        });
      }
    });
  }
  onunload() {
    console.log("Unloading Obsidunlime plugin");
    if (this.styleEl) {
      this.styleEl.remove();
    }
    if (this.observer) {
      this.observer.disconnect();
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.updateUnlinkedMentionsVisibility();
  }
  updateUnlinkedMentionsVisibility() {
    this.log("updateUnlinkedMentionsVisibility called, hideUnlinkedMentions:", this.settings.hideUnlinkedMentions, "hideUnlinkedMentionsOutgoing:", this.settings.hideUnlinkedMentionsOutgoing);
    this.styleEl.textContent = "";
    const panelTypes = [];
    if (this.settings.hideUnlinkedMentions) {
      panelTypes.push("backlink");
    }
    if (this.settings.hideUnlinkedMentionsOutgoing) {
      panelTypes.push("outgoing-link");
    }
    if (panelTypes.length > 0) {
      setTimeout(() => {
        this.hideUnlinkedMentionsByText(panelTypes);
      }, 200);
    } else {
      this.showUnlinkedMentions();
    }
  }
  hideUnlinkedMentionsByText(panelTypes) {
    this.log("hideUnlinkedMentionsByText called for panel types:", panelTypes);
    panelTypes.forEach((panelType) => {
      const panelContainers = document.querySelectorAll(`.workspace-leaf-content[data-type="${panelType}"]`);
      this.log(`Found ${panelContainers.length} panel containers for type: ${panelType}`);
      panelContainers.forEach((container, index) => {
        this.log(`Processing container ${index + 1} for ${panelType}:`, container);
        if (panelType === "outgoing-link") {
          this.log(`Processing outgoing links panel with improved logic`);
        }
        const treeItemSelfs = container.querySelectorAll(".tree-item-self");
        this.log(`Found ${treeItemSelfs.length} tree-item-self elements`);
        treeItemSelfs.forEach((treeItemSelf, selfIndex) => {
          const textContent = treeItemSelf.textContent || "";
          this.log(`Tree-item-self ${selfIndex + 1} text: "${textContent.trim()}"`);
          if (textContent.trim() === "Unlinked mentions") {
            this.log(`Found exact unlinked mentions header in ${panelType}:`, treeItemSelf);
            const parentTreeItem = treeItemSelf.closest(".tree-item");
            if (parentTreeItem && !parentTreeItem.dataset.obsidunlimeHidden) {
              this.log(`Hiding parent tree-item:`, parentTreeItem);
              parentTreeItem.dataset.obsidunlimeHidden = "true";
              parentTreeItem.style.display = "none";
              let nextSibling = parentTreeItem.nextElementSibling;
              while (nextSibling && nextSibling.classList.contains("tree-item-children")) {
                const htmlSibling = nextSibling;
                this.log(`Hiding adjacent tree-item-children:`, htmlSibling);
                htmlSibling.dataset.obsidunlimeHidden = "true";
                htmlSibling.style.display = "none";
                nextSibling = nextSibling.nextElementSibling;
              }
            }
          }
        });
        const treeItemInners = container.querySelectorAll(".tree-item-inner");
        this.log(`Found ${treeItemInners.length} tree-item-inner elements`);
        treeItemInners.forEach((inner, innerIndex) => {
          const text = inner.textContent || "";
          this.log(`Tree-item-inner ${innerIndex + 1} text: "${text.trim()}"`);
          if (text.trim() === "Unlinked mentions") {
            this.log(`Found unlinked mentions in tree-item-inner:`, inner);
            let containerToHide = null;
            const parentTreeItem = inner.closest(".tree-item");
            const parentTreeItemSelf = inner.closest(".tree-item-self");
            const parentCollapsible = inner.closest(".is-clickable");
            const parentWithCollapse = inner.closest('[aria-label*="collapse"]');
            const searchResultContainer = inner.closest(".search-result-container");
            const viewContent = inner.closest(".view-content");
            const navFolder = inner.closest(".nav-folder");
            this.log(`Parent tree-item found:`, parentTreeItem);
            this.log(`Parent tree-item-self found:`, parentTreeItemSelf);
            this.log(`Parent collapsible found:`, parentCollapsible);
            this.log(`Parent with collapse found:`, parentWithCollapse);
            this.log(`Search result container found:`, searchResultContainer);
            this.log(`View content found:`, viewContent);
            this.log(`Nav folder found:`, navFolder);
            containerToHide = searchResultContainer || navFolder || parentTreeItem || parentTreeItemSelf || parentCollapsible || parentWithCollapse;
            if (containerToHide && !containerToHide.dataset.obsidunlimeHidden) {
              this.log(`Hiding container:`, containerToHide);
              containerToHide.dataset.obsidunlimeHidden = "true";
              containerToHide.style.display = "none";
              this.hideUnlinkedMentionsContentAfterHeader(container, containerToHide);
            } else if (!containerToHide) {
              this.log(`No suitable parent container found, trying direct parent approach`);
              let parent = inner.parentElement;
              while (parent && parent !== container && !parent.dataset.obsidunlimeHidden) {
                this.log(`Checking parent:`, parent, `Classes:`, parent.className);
                if (parent.classList.contains("tree-item-self") || parent.classList.contains("is-clickable") || parent.hasAttribute("aria-label")) {
                  this.log(`Hiding direct parent:`, parent);
                  parent.dataset.obsidunlimeHidden = "true";
                  parent.style.display = "none";
                  break;
                }
                parent = parent.parentElement;
              }
            } else {
              this.log(`Container already marked as hidden`);
            }
            this.log(`Looking for unlinked mention content immediately following the header...`);
            this.hideUnlinkedMentionsContentAfterHeader(container, containerToHide);
          }
        });
      });
    });
  }
  hideUnlinkedMentionsContentAfterHeader(container, unlinkedMentionsHeader) {
    var _a, _b;
    if (!unlinkedMentionsHeader)
      return;
    const panelType = ((_a = container.closest("[data-type]")) == null ? void 0 : _a.getAttribute("data-type")) || "unknown";
    this.log(`Hiding unlinked content for ${panelType} panel`);
    let currentElement = unlinkedMentionsHeader.nextElementSibling;
    while (currentElement) {
      const htmlElement = currentElement;
      if (this.isNewSectionHeader(currentElement)) {
        this.log(`Found next section header, stopping traversal:`, currentElement);
        break;
      }
      if (this.isDefinitelyUnlinkedContent(currentElement, panelType)) {
        this.log(`Hiding unlinked content element in ${panelType}:`, currentElement);
        this.log(`  - Classes: ${currentElement.className}`);
        this.log(`  - Text: "${(_b = currentElement.textContent) == null ? void 0 : _b.trim().substring(0, 100)}..."`);
        htmlElement.dataset.obsidunlimeHidden = "true";
        htmlElement.style.display = "none";
      }
      currentElement = currentElement.nextElementSibling;
    }
  }
  isNewSectionHeader(element) {
    var _a, _b;
    const text = ((_a = element.textContent) == null ? void 0 : _a.trim()) || "";
    const sectionHeaders = [
      "Linked mentions",
      "Unlinked mentions",
      // Backlinks panel
      "Links",
      "Unlinked mentions"
      // Outgoing links panel (may use different naming)
    ];
    if (element.classList.contains("tree-item-self")) {
      const innerElement = element.querySelector(".tree-item-inner");
      if (innerElement) {
        const innerText = ((_b = innerElement.textContent) == null ? void 0 : _b.trim()) || "";
        if (sectionHeaders.includes(innerText)) {
          return true;
        }
        if (!sectionHeaders.includes(innerText) && innerText.length > 0) {
          return true;
        }
      }
    }
    return false;
  }
  isDefinitelyUnlinkedContent(element, panelType) {
    var _a;
    if (element.classList.contains("tree-item-children") || element.classList.contains("search-result-container")) {
      return true;
    }
    const text = ((_a = element.textContent) == null ? void 0 : _a.trim()) || "";
    if (text.includes("No unlinked mentions found") || text.includes("No matches found")) {
      return true;
    }
    if (panelType === "outgoing-link") {
      if (text.includes("No unlinked files found") || text.includes("No unresolved links")) {
        return true;
      }
    } else if (panelType === "backlink") {
    }
    return false;
  }
  showUnlinkedMentions() {
    this.log("showUnlinkedMentions called");
    const hiddenElements = document.querySelectorAll('[data-obsidunlime-hidden="true"]');
    hiddenElements.forEach((element) => {
      const htmlElement = element;
      this.log("Restoring element:", htmlElement);
      delete htmlElement.dataset.obsidunlimeHidden;
      htmlElement.style.removeProperty("display");
      htmlElement.style.removeProperty("visibility");
      htmlElement.style.removeProperty("height");
      htmlElement.style.removeProperty("overflow");
    });
  }
};
var ObsidunlimeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidunlime Settings" });
    new import_obsidian.Setting(containerEl).setName("Unlinked mentions (backlinks)").setDesc('Hide the "Unlinked mentions" section in the Backlinks panel').addToggle((toggle) => toggle.setValue(this.plugin.settings.hideUnlinkedMentions).onChange(async (value) => {
      this.plugin.settings.hideUnlinkedMentions = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Unlinked mentions (outgoing links)").setDesc('Hide the "Unlinked mentions" section in the Outgoing links panel').addToggle((toggle) => toggle.setValue(this.plugin.settings.hideUnlinkedMentionsOutgoing).onChange(async (value) => {
      this.plugin.settings.hideUnlinkedMentionsOutgoing = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Verbose logging").setDesc("Enable detailed console logging for debugging purposes").addToggle((toggle) => toggle.setValue(this.plugin.settings.verboseLogging).onChange(async (value) => {
      this.plugin.settings.verboseLogging = value;
      await this.plugin.saveSettings();
    }));
  }
};
